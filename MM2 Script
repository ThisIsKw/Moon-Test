local GUI = loadstring(game:HttpGet("https://usemoon.xyz/library"))()

local UDimSize
if game:GetService("UserInputService").TouchEnabled then
    UDimSize = UDim2.fromOffset(490, 290)
else
    UDimSize = UDim2.fromOffset(600, 335)
end

local main = GUI:CreateWindow({
    Title = "MOON running in " .. identifyexecutor(),
    SubTitle = "MM2",
    Icon = "moon",
    TabWidth = 50,
    Size = UDimSize,
    Theme = "supernova",
    MinimizeKey = Enum.KeyCode.M
})

local sheriffTab = main:AddTab({ Title = "Sheriff", Icon = "crosshair" })
local murderTab = main:AddTab({ Title = "Murder", Icon = "skull" })
local playerTab = main:AddTab({ Title = "Player", Icon = "user" })
local visualTab = main:AddTab({ Title = "Visual", Icon = "eye" })
local autoFarmTab = main:AddTab({ Title = "Auto Farm", Icon = "zap" })
local settingsTab = main:AddTab({ Title = "Settings", Icon = "settings" })

local functions = {}
local connections = {}

function functions.createconnection(name, source, callback, delay)
    if connections[name] then
        connections[name]:Disconnect()
    end

    local locked = false

    local function handler(...)
        if delay then
            if locked then return end
            locked = true
            task.delay(delay, function()
                locked = false
            end)
        end
        callback(...)
    end

    local signal =
        typeof(source) == "string" and game:GetService("RunService")[source]
        or typeof(source) == "RBXScriptSignal" and source
        or (type(source) == "table" and source.Connect and source)

    if not signal then
        return nil
    end

    connections[name] = signal:Connect(handler)
    return connections[name]
end

function functions.closeconnection(name)
    if connections[name] then
        connections[name]:Disconnect()
        connections[name] = nil
        return true
    end
    return false
end


-- ==================== CONFIGURAÇÕES ====================

local sheriffConfig = {
    showButton = false,
    PingPrediction = true,
    PingSensitivity = 1.18,
    JumpPrediction = true,
    HorizontalMultiplier = 1.00,
    VerticalMultiplier = 1.00,
    MaxPredictionDistance = 350.00,
    VerticalDistanceScale = 2.00,
    LeadTime = 0.01,
    XMultiplier = 0.00,
    ZMultiplier = 0.00,
    UnequipAfterShot = false
}

local hitboxConfig = {
    enabled = false,
    size = 10,
    visible = true,
    transparency = 0.5,
    color = Color3.fromRGB(255, 0, 80)
}

local espConfig = {
    enabled = false,
    innocentColor = Color3.fromHex("#00ff00"),
    sheriffColor = Color3.fromHex("#0026ff"),
    murdererColor = Color3.fromHex("#ff0000"),
    nameEnabled = true,
    nameSize = 14,
    gunEnabled = false,
    coinEnabled = false
}

-- ==================== VARIÁVEIS DE ESTADO ====================

local pingCache = 0
local lastPingUpdate = 0
local PING_UPDATE_INTERVAL = 0.15

local MY_SPEED = 16
local MY_JUMP = 50
local noclipActive = false

local espConnections = {}
local espRunning = false

local podeAtirar = true
local delayTiro = 0.3
local delayHolster = 0.0

local autoShotConfig = {
    wallCheck = false
}

local shotStats = {
    totalShots = 0,
    lastShotTime = 0,
    avgDistance = 0
}

local BULLET_SPEED = 500

local botaoTela = nil
local botaoArrastavel = false
local tamanhoBot = 80
local BOTAO_POS_FILE = "moon/mm2/botao_pos.txt"

local function salvarPosicaoBotao(pos)
    pcall(function()
        local data = string.format("%.6f,%.2f,%.6f,%.2f",
            pos.X.Scale, pos.X.Offset,
            pos.Y.Scale, pos.Y.Offset)
        writefile(BOTAO_POS_FILE, data)
    end)
end

local function carregarPosicaoBotao()
    local ok, data = pcall(readfile, BOTAO_POS_FILE)
    if not ok or not data or data == "" then return nil end
    local xs, xo, ys, yo = data:match("([^,]+),([^,]+),([^,]+),([^,]+)")
    if not xs then return nil end
    return UDim2.new(tonumber(xs), tonumber(xo), tonumber(ys), tonumber(yo))
end

local savedBotaoPos = carregarPosicaoBotao() or UDim2.new(0.85, 0, 0.5, 0)

-- ==================== UTILITÁRIOS ====================

local function getPing()
    local currentTime = tick()
    if currentTime - lastPingUpdate > PING_UPDATE_INTERVAL then
        pingCache = game.Players.LocalPlayer:GetNetworkPing() * 1000
        lastPingUpdate = currentTime
    end
    return pingCache
end

local velocityHistory = {}
local accelerationHistory = {}

local function DesequiparArmaRapido()
    local char = game.Players.LocalPlayer.Character
    if not char then return end

    local arma = char:FindFirstChild("Gun")
    if arma then
        local hum = char:FindFirstChild("Humanoid")
        if hum then
            hum:UnequipTools()
        end
    end
end

local W_TOTALS = { [2] = 3, [4] = 10, [6] = 21 }

local DIRECTION_CHANGE_THRESHOLD = math.cos(math.rad(55))

local function getBufSize(speed)
    if speed > 35 then return 2
    elseif speed > 22 then return 4
    else return 6 end
end

local function getSmoothedVelocity(hrp)
    local current = hrp.Velocity
    local now     = tick()
    local speed   = Vector2.new(current.X, current.Z).Magnitude
    local bufSize = getBufSize(speed)

    if not velocityHistory[hrp] then
        velocityHistory[hrp] = {}
        for i = 1, bufSize do
            velocityHistory[hrp][i] = { vel = current, t = now - (bufSize - i) * 0.016 }
        end
        accelerationHistory[hrp] = Vector3.new(0, 0, 0)
        return current, false
    end

    local h       = velocityHistory[hrp]
    local prevSize = #h

    if bufSize < prevSize then
        local trimmed = {}
        for i = prevSize - bufSize + 1, prevSize do
            trimmed[#trimmed + 1] = h[i]
        end
        velocityHistory[hrp] = trimmed
        h = trimmed
    elseif bufSize > prevSize then
        local expanded = {}
        local oldest   = h[1]
        for i = 1, bufSize - prevSize do
            expanded[i] = { vel = oldest.vel, t = oldest.t - (bufSize - prevSize - i + 1) * 0.016 }
        end
        for i = 1, prevSize do
            expanded[bufSize - prevSize + i] = h[i]
        end
        velocityHistory[hrp] = expanded
        h = expanded
    end

    local lastVel = h[bufSize].vel
    local curXZ   = Vector2.new(current.X, current.Z)
    local lastXZ  = Vector2.new(lastVel.X, lastVel.Z)
    local curMag  = curXZ.Magnitude
    local lastMag = lastXZ.Magnitude

    if curMag > 2 and lastMag > 2 then
        local dot = (curXZ / curMag):Dot(lastXZ / lastMag)
        if dot < DIRECTION_CHANGE_THRESHOLD then
            for i = 1, bufSize do
                h[i] = { vel = current, t = now - (bufSize - i) * 0.016 }
            end
            accelerationHistory[hrp] = Vector3.new(0, 0, 0)
            return current, true
        end
    end

    for i = 1, bufSize - 1 do
        h[i] = h[i + 1]
    end
    h[bufSize] = { vel = current, t = now }

    local sumT, sumVx, sumVz = 0, 0, 0
    local sumT2, sumTVx, sumTVz = 0, 0, 0
    local t0 = h[1].t
    for i = 1, bufSize do
        local dt  = h[i].t - t0
        local vx  = h[i].vel.X
        local vz  = h[i].vel.Z
        sumT   = sumT   + dt
        sumVx  = sumVx  + vx
        sumVz  = sumVz  + vz
        sumT2  = sumT2  + dt * dt
        sumTVx = sumTVx + dt * vx
        sumTVz = sumTVz + dt * vz
    end
    local denom = bufSize * sumT2 - sumT * sumT
    local accelX, accelZ = 0, 0
    if math.abs(denom) > 1e-6 then
        accelX = (bufSize * sumTVx - sumT * sumVx) / denom
        accelZ = (bufSize * sumTVz - sumT * sumVz) / denom
    end
    accelerationHistory[hrp] = Vector3.new(accelX, 0, accelZ)

    local wTotal = W_TOTALS[bufSize] or (bufSize * (bufSize + 1) / 2)
    local sv = Vector3.new(0, 0, 0)
    for i = 1, bufSize do
        sv = sv + h[i].vel * i
    end
    return sv / wTotal, false
end

local function getAcceleration(hrp)
    return accelerationHistory[hrp] or Vector3.new(0, 0, 0)
end

local function getLastReplicationTime(hrp)
    local h = velocityHistory[hrp]
    if not h or #h == 0 then return tick() end
    return h[#h].t
end

local function CalcularPredicaoRapida(alvoHRP, alvoAim, minhaPos)
    if not alvoHRP or not alvoHRP.Parent then return nil end
    if not alvoAim or not alvoAim.Parent then return nil end

    local alvoVelRaw                = alvoHRP.Velocity
    local alvoVelSmooth, dirChanged = getSmoothedVelocity(alvoHRP)
    local alvoAccel                 = getAcceleration(alvoHRP)

    local lastRepTime    = getLastReplicationTime(alvoHRP)
    local repLag         = math.min(tick() - lastRepTime, 0.05)

    local velExtrapX = alvoVelRaw.X + alvoAccel.X * repLag
    local velExtrapZ = alvoVelRaw.Z + alvoAccel.Z * repLag
    local velExtrap  = Vector3.new(velExtrapX, alvoVelRaw.Y, velExtrapZ)

    local velSmExtrapX = alvoVelSmooth.X + alvoAccel.X * repLag
    local velSmExtrapZ = alvoVelSmooth.Z + alvoAccel.Z * repLag
    local velSmExtrap  = Vector3.new(velSmExtrapX, alvoVelSmooth.Y, velSmExtrapZ)

    local vel = dirChanged and velExtrap or velSmExtrap

    local hrpExtrapolado = alvoHRP.Position + vel * repLag
    local headOffset     = alvoAim.Position - alvoHRP.Position
    local alvoPos        = hrpExtrapolado + headOffset

    local dist = (alvoPos - minhaPos).Magnitude

    local pingTime = 0
    if sheriffConfig.PingPrediction then
        local ping = getPing()
        pingTime = ping * 0.001 * sheriffConfig.PingSensitivity
        if    ping > 150 then pingTime = pingTime * 1.35
        elseif ping > 100 then pingTime = pingTime * 1.2 end
    end

    local CONV_STUDS = 0.08
    local extraTime  = pingTime + sheriffConfig.LeadTime
    local horizDist  = Vector2.new(alvoPos.X - minhaPos.X, alvoPos.Z - minhaPos.Z).Magnitude
    local totalTime  = horizDist / BULLET_SPEED + extraTime
    local w_conv     = 0.50

    for i = 0, 7 do
        local w     = math.max(0.40, 0.50 - i * 0.02)
        local t_voo = totalTime - extraTime
        local futureX = alvoPos.X + vel.X * totalTime + w * alvoAccel.X * t_voo * t_voo
        local futureZ = alvoPos.Z + vel.Z * totalTime + w * alvoAccel.Z * t_voo * t_voo
        local newDist = Vector2.new(futureX - minhaPos.X, futureZ - minhaPos.Z).Magnitude
        local t_new   = newDist / BULLET_SPEED + extraTime
        if math.abs(t_new - totalTime) * BULLET_SPEED < CONV_STUDS then
            w_conv    = w
            totalTime = t_new
            break
        end
        w_conv    = w
        totalTime = t_new
    end

    local t_voo_final = totalTime - extraTime
    local finalX = alvoPos.X + vel.X * totalTime + w_conv * alvoAccel.X * t_voo_final * t_voo_final
    local finalZ = alvoPos.Z + vel.Z * totalTime + w_conv * alvoAccel.Z * t_voo_final * t_voo_final

    local horizVelRaw = Vector2.new(alvoVelRaw.X, alvoVelRaw.Z).Magnitude
    local horizAccel  = Vector2.new(alvoAccel.X, alvoAccel.Z).Magnitude
    if horizVelRaw < 3 and horizAccel > 2 then
        finalX = alvoPos.X + vel.X * totalTime * 0.4
        finalZ = alvoPos.Z + vel.Z * totalTime * 0.4
    end

    local deltaX = (finalX - alvoPos.X) * sheriffConfig.HorizontalMultiplier + (sheriffConfig.XMultiplier * 10)
    local deltaZ = (finalZ - alvoPos.Z) * sheriffConfig.HorizontalMultiplier + (sheriffConfig.ZMultiplier * 10)

    local deltaY  = 0
    local velY    = alvoVelRaw.Y
    local gravity = 196.2

    if sheriffConfig.JumpPrediction then
        local hum        = alvoHRP.Parent and alvoHRP.Parent:FindFirstChild("Humanoid")
        local state      = hum and hum:GetState()
        local isAirborne = state == Enum.HumanoidStateType.Freefall
                        or state == Enum.HumanoidStateType.Jumping

        if isAirborne then
            local rayParams = RaycastParams.new()
            rayParams.FilterType = Enum.RaycastFilterType.Blacklist
            rayParams.FilterDescendantsInstances = { alvoHRP.Parent }
            local rayResult = workspace:Raycast(alvoHRP.Position, Vector3.new(0, -50, 0), rayParams)
            local groundDist = rayResult and (alvoHRP.Position.Y - rayResult.Position.Y) or 999

            local headAboveGround = headOffset.Y + 3

            local tPouso = 999
            if velY < 0 then
                local a_eq = 0.5 * gravity
                local b_eq = -velY
                local c_eq = -groundDist
                local disc  = b_eq * b_eq - 4 * a_eq * c_eq
                if disc >= 0 then
                    local r1 = (-b_eq + math.sqrt(disc)) / (2 * a_eq)
                    local r2 = (-b_eq - math.sqrt(disc)) / (2 * a_eq)
                    if r1 > 0 and r2 > 0 then tPouso = math.min(r1, r2)
                    elseif r1 > 0 then tPouso = r1
                    elseif r2 > 0 then tPouso = r2 end
                end
            end

            local gravCorrection = gravity * repLag * totalTime

            if tPouso < totalTime then
                if rayResult then
                    local groundY = rayResult.Position.Y
                    deltaY = (groundY + headAboveGround) - alvoPos.Y
                else
                    deltaY = (velY * totalTime) - (0.5 * gravity * totalTime * totalTime) - gravCorrection
                end
            else
                deltaY = (velY * totalTime) - (0.5 * gravity * totalTime * totalTime) - gravCorrection
            end

            deltaY = deltaY * sheriffConfig.VerticalMultiplier
        end
    end

    local horizDistDrop = Vector2.new(alvoPos.X - minhaPos.X, alvoPos.Z - minhaPos.Z).Magnitude
    if horizDistDrop > 80 then
        deltaY = deltaY - (horizDistDrop - 80) * 0.008 * sheriffConfig.VerticalDistanceScale
    end

    return Vector3.new(alvoPos.X + deltaX, alvoPos.Y + deltaY, alvoPos.Z + deltaZ)
end


-- ==================== AUTO SHOT - LÓGICA AVANÇADA ====================


local function hasLineOfSight(fromPos, toPos)
    if not autoShotConfig.wallCheck then return true end

    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character}

    local result = workspace:Raycast(fromPos, (toPos - fromPos), rayParams)

    if result then
        local hitModel = result.Instance:FindFirstAncestorOfClass("Model")
        if hitModel and game.Players:GetPlayerFromCharacter(hitModel) then
            return true
        end
        return false
    end

    return true
end

local function getScoreForTarget(hrp, myPos)
    local score = 0
    local dist = (hrp.Position - myPos).Magnitude

    score = score + (1500 - dist)

    if autoShotConfig.wallCheck and hasLineOfSight(myPos, hrp.Position) then
        score = score + 500
    end

    local vel = hrp.Velocity.Magnitude
    score = score - (vel * 5)

    local hum = hrp.Parent and hrp.Parent:FindFirstChild("Humanoid")
    if hum then
        local state = hum:GetState()
        if state ~= Enum.HumanoidStateType.Freefall and state ~= Enum.HumanoidStateType.Flying then
            score = score + 200
        end
    end

    return score
end

local function AcharMelhorAlvo()
    local char = game.Players.LocalPlayer.Character
    if not char then return nil end

    local myPos = char:FindFirstChild("HumanoidRootPart")
    if not myPos then return nil end
    myPos = myPos.Position

    local bestTarget = nil
    local bestScore = -math.huge

    local players = game.Players:GetPlayers()
    for i = 1, #players do
        local v = players[i]
        if v ~= game.Players.LocalPlayer and v.Parent then
            local vChar = v.Character
            if vChar and vChar.Parent then
                local hrp = vChar:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local backpack = v:FindFirstChild("Backpack")
                    if (vChar:FindFirstChild("Knife")) or (backpack and backpack:FindFirstChild("Knife")) then
                        local score = getScoreForTarget(hrp, myPos)
                        if score > bestScore then
                            bestScore = score
                            bestTarget = hrp
                        end
                    end
                end
            end
        end
    end

    return bestTarget
end

-- ==================== AUTO SHOT ====================

local equipAttempts = 0

local function Atirar()
    if not podeAtirar then return end

    local char = game.Players.LocalPlayer.Character
    if not char or not char.Parent then return end

    local hum = char:FindFirstChild("Humanoid")
    if not hum or hum.Health <= 0 then return end

    local head = char:FindFirstChild("Head")
    if not head then return end

    local alvo = AcharMelhorAlvo()
    if not alvo or not alvo.Parent then return end

    local humAlvo = alvo.Parent:FindFirstChild("Humanoid")
    if not humAlvo or humAlvo.Health <= 0 then return end

    local headAlvo   = alvo.Parent:FindFirstChild("Head")
    local alvoAimPos = headAlvo or alvo

    local dist = (alvoAimPos.Position - head.Position).Magnitude
    if dist > sheriffConfig.MaxPredictionDistance then return end

    if autoShotConfig.wallCheck and not hasLineOfSight(head.Position, alvo.Position) then
        return
    end

    local arma = char:FindFirstChild("Gun")
    if not arma then
        if equipAttempts >= 3 then
            equipAttempts = 0
            return
        end
        local gunInBackpack = game.Players.LocalPlayer.Backpack:FindFirstChild("Gun")
        if not gunInBackpack then equipAttempts = 0; return end

        equipAttempts = equipAttempts + 1
        task.spawn(function()
            hum:EquipTool(gunInBackpack)
            task.wait(0.05)
            if podeAtirar then Atirar() end
        end)
        return
    end
    equipAttempts = 0

    local evento = arma:FindFirstChild("Shoot")
    if not evento then return end

    local function executarTiro()
        if not podeAtirar then return end
        if not alvo or not alvo.Parent then return end
        if not humAlvo or humAlvo.Health <= 0 then return end
        if not alvoAimPos or not alvoAimPos.Parent then return end

        local posPredicao = CalcularPredicaoRapida(alvo, alvoAimPos, head.Position)
        if not posPredicao then return end

        local velMag       = alvoVelRaw.Magnitude
        local sanityLimit  = math.max(40, velMag * totalTime * 1.5)
        if (posPredicao - alvoAimPos.Position).Magnitude > sanityLimit then
            posPredicao = alvoAimPos.Position
        end

        evento:FireServer(CFrame.new(head.Position, posPredicao), CFrame.new(posPredicao))

        podeAtirar = false

        local distAtual = (alvoAimPos.Position - head.Position).Magnitude
        local adaptiveDelay
        if distAtual < 50 then
            adaptiveDelay = delayTiro * 0.7
        elseif distAtual < 120 then
            adaptiveDelay = delayTiro
        elseif distAtual < 220 then
            adaptiveDelay = delayTiro * 1.3
        else
            adaptiveDelay = delayTiro * 1.6
        end
        task.delay(adaptiveDelay, function() podeAtirar = true end)

        if sheriffConfig.UnequipAfterShot then
            task.delay(delayHolster > 0 and delayHolster or 0.05, DesequiparArmaRapido)
        end
    end

    local stateAlvo = humAlvo:GetState()
    local velYAlvo  = alvo.Velocity.Y
    local noApex    = (stateAlvo == Enum.HumanoidStateType.Freefall
                    or stateAlvo == Enum.HumanoidStateType.Jumping)
                   and math.abs(velYAlvo) < 8

    if noApex then
        podeAtirar = false
        local apexConn
        local timeoutHandle = task.delay(0.12, function()
            if apexConn then apexConn:Disconnect(); apexConn = nil end
            podeAtirar = true
            executarTiro()
        end)
        apexConn = game:GetService("RunService").Heartbeat:Connect(function()
            if not apexConn then return end
            if not alvo or not alvo.Parent then
                apexConn:Disconnect(); apexConn = nil
                task.cancel(timeoutHandle)
                podeAtirar = true
                return
            end
            if alvo.Velocity.Y < -5 then
                apexConn:Disconnect(); apexConn = nil
                task.cancel(timeoutHandle)
                podeAtirar = true
                executarTiro()
            end
        end)
    else
        executarTiro()
    end
end

-- ==================== BOTÃO NA TELA ====================

local function CriarBotaoTela()
    if botaoTela then return end

    local sg = Instance.new("ScreenGui")
    sg.Name = "SilentAimBtnUltra"
    sg.ResetOnSpawn = false
    sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    sg.IgnoreGuiInset = true

    local container = Instance.new("Frame")
    container.Name = "MainContainer"
    container.Size = UDim2.new(0, tamanhoBot, 0, tamanhoBot)
    container.Position = savedBotaoPos
    container.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    container.BackgroundTransparency = 0.3
    container.BorderSizePixel = 0
    container.Parent = sg

    local containerCorner = Instance.new("UICorner")
    containerCorner.CornerRadius = UDim.new(0, 12)
    containerCorner.Parent = container

    local outerCircle = Instance.new("Frame")
    outerCircle.Name = "OuterCircle"
    outerCircle.Size = UDim2.new(0, tamanhoBot * 0.6, 0, tamanhoBot * 0.6)
    outerCircle.Position = UDim2.new(0.5, 0, 0.5, 0)
    outerCircle.AnchorPoint = Vector2.new(0.5, 0.5)
    outerCircle.BackgroundTransparency = 1
    outerCircle.BorderSizePixel = 0
    outerCircle.Parent = container

    local outerStroke = Instance.new("UIStroke")
    outerStroke.Color = Color3.fromRGB(255, 255, 255)
    outerStroke.Thickness = 3
    outerStroke.Parent = outerCircle

    Instance.new("UICorner", outerCircle).CornerRadius = UDim.new(1, 0)

    local centerDot = Instance.new("Frame")
    centerDot.Name = "CenterDot"
    centerDot.Size = UDim2.new(0, tamanhoBot * 0.15, 0, tamanhoBot * 0.15)
    centerDot.Position = UDim2.new(0.5, 0, 0.5, 0)
    centerDot.AnchorPoint = Vector2.new(0.5, 0.5)
    centerDot.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    centerDot.BorderSizePixel = 0
    centerDot.Parent = container
    Instance.new("UICorner", centerDot).CornerRadius = UDim.new(1, 0)

    local function createAimLine(name, rotation, xOffset, yOffset)
        local line = Instance.new("Frame")
        line.Name = name
        line.Size = UDim2.new(0, 3, 0, tamanhoBot * 0.12)
        line.Position = UDim2.new(0.5, xOffset, 0.5, yOffset)
        line.AnchorPoint = Vector2.new(0.5, 0.5)
        line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        line.BorderSizePixel = 0
        line.Rotation = rotation
        line.Parent = container
        Instance.new("UICorner", line).CornerRadius = UDim.new(1, 0)
    end

    createAimLine("TopLine",    0,    0,              -(tamanhoBot * 0.25))
    createAimLine("BottomLine", 0,    0,               (tamanhoBot * 0.25))
    createAimLine("LeftLine",   90, -(tamanhoBot * 0.25), 0)
    createAimLine("RightLine",  90,  (tamanhoBot * 0.25), 0)

    local btn = Instance.new("TextButton")
    btn.Name = "ClickButton"
    btn.Size = UDim2.new(1, 0, 1, 0)
    btn.BackgroundTransparency = 1
    btn.Text = ""
    btn.AutoButtonColor = false
    btn.Parent = container

    local function setPressed(on)
        container.BackgroundTransparency = on and 0.05 or 0.3
        outerStroke.Color = on and Color3.fromRGB(255, 80, 80) or Color3.fromRGB(255, 255, 255)
    end

    local lastClickTime = 0
    btn.InputBegan:Connect(function(input)
        local isTouch = input.UserInputType == Enum.UserInputType.Touch
        local isMouse = input.UserInputType == Enum.UserInputType.MouseButton1

        if isTouch or isMouse then
            if botaoArrastavel then
                local startPos = input.Position
                local startFrame = container.Position
                local moved = false

                local moveConn, endConn
                moveConn = game:GetService("UserInputService").InputChanged:Connect(function(inp)
                    if inp == input or inp.UserInputType == Enum.UserInputType.MouseMovement then
                        local delta = inp.Position - startPos
                        if delta.Magnitude > 5 then moved = true end
                        container.Position = UDim2.new(
                            startFrame.X.Scale,
                            startFrame.X.Offset + delta.X,
                            startFrame.Y.Scale,
                            startFrame.Y.Offset + delta.Y
                        )
                    end
                end)

                endConn = input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        savedBotaoPos = container.Position
                        salvarPosicaoBotao(savedBotaoPos)
                        moveConn:Disconnect()
                        endConn:Disconnect()
                    end
                end)
            else
                local success, errorMsg = pcall(function()
                    setPressed(true)
                    Atirar()
                    task.delay(0.1, function() setPressed(false) end)
                end)

                if not success then
                    setPressed(false)
                    warn("Button Shot Error:", errorMsg)
                end
            end
        end
    end)

    sg.Parent = game:GetService("CoreGui")
    botaoTela = sg
end

local function RemoverBotaoTela()
    if botaoTela then
        botaoTela:Destroy()
        botaoTela = nil
    end
end

local function AtualizarTamanhoBotao()
    if not botaoTela then return end
    local container = botaoTela:FindFirstChild("MainContainer")
    if not container then return end

    container.Size = UDim2.new(0, tamanhoBot, 0, tamanhoBot)

    local outerCircle = container:FindFirstChild("OuterCircle")
    if outerCircle then
        outerCircle.Size = UDim2.new(0, tamanhoBot * 0.6, 0, tamanhoBot * 0.6)
    end

    local centerDot = container:FindFirstChild("CenterDot")
    if centerDot then
        centerDot.Size = UDim2.new(0, tamanhoBot * 0.15, 0, tamanhoBot * 0.15)
    end

    local lines = {
        { name = "TopLine",    xOff = 0,                  yOff = -(tamanhoBot * 0.25) },
        { name = "BottomLine", xOff = 0,                  yOff =  (tamanhoBot * 0.25) },
        { name = "LeftLine",   xOff = -(tamanhoBot * 0.25), yOff = 0                  },
        { name = "RightLine",  xOff =  (tamanhoBot * 0.25), yOff = 0                  },
    }
    for _, d in ipairs(lines) do
        local line = container:FindFirstChild(d.name)
        if line then
            line.Size = UDim2.new(0, 3, 0, tamanhoBot * 0.12)
            line.Position = UDim2.new(0.5, d.xOff, 0.5, d.yOff)
        end
    end
end

-- ==================== HITBOX ====================
local hitboxParts = {}
local hitboxConnections = {}
local originalSizes = {}

local function createHitboxForPlayer(player)
    if player == game.Players.LocalPlayer then return end
    if not player.Character then return end

    local character = player.Character
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local playerName = player.Name

    if not originalSizes[playerName] then
        originalSizes[playerName] = hrp.Size
    end

    hrp.Size = Vector3.new(hitboxConfig.size, hitboxConfig.size, hitboxConfig.size)
    hrp.Transparency = 0.9
    hrp.Material = Enum.Material.ForceField
    hrp.CanCollide = false

    local oldVisual = hrp:FindFirstChild("HitboxVisual")
    if oldVisual then oldVisual:Destroy() end

    if hitboxConfig.visible then
        local box = Instance.new("BoxHandleAdornment")
        box.Name = "HitboxVisual"
        box.Adornee = hrp
        box.Size = hrp.Size
        box.Color3 = hitboxConfig.color
        box.Transparency = hitboxConfig.transparency
        box.AlwaysOnTop = true
        box.ZIndex = 1
        box.Parent = hrp
    end

    hitboxParts[playerName] = hrp
end

local function updateAllHitboxes()
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer and player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local newSize = Vector3.new(hitboxConfig.size, hitboxConfig.size, hitboxConfig.size)
                if hrp.Size ~= newSize then
                    hrp.Size = newSize
                    hrp.Transparency = 0.9
                    hrp.Material = Enum.Material.ForceField
                    hrp.CanCollide = false
                end
                local visual = hrp:FindFirstChild("HitboxVisual")
                if hitboxConfig.visible then
                    if not visual then
                        visual = Instance.new("BoxHandleAdornment")
                        visual.Name = "HitboxVisual"
                        visual.Adornee = hrp
                        visual.AlwaysOnTop = true
                        visual.ZIndex = 1
                        visual.Parent = hrp
                    end
                    visual.Size = hrp.Size
                    visual.Color3 = hitboxConfig.color
                    visual.Transparency = hitboxConfig.transparency
                else
                    if visual then visual:Destroy() end
                end
            else
                createHitboxForPlayer(player)
            end
        end
    end
end

local function startHitbox()
    for _, player in ipairs(game.Players:GetPlayers()) do
        createHitboxForPlayer(player)
    end

    hitboxConnections.playerAdded = game.Players.PlayerAdded:Connect(function(player)
        hitboxConnections[player.Name] = player.CharacterAdded:Connect(function()
            task.wait(0.5)
            if hitboxConfig.enabled then
                createHitboxForPlayer(player)
            end
        end)
    end)

    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            hitboxConnections[player.Name] = player.CharacterAdded:Connect(function()
                task.wait(0.5)
                if hitboxConfig.enabled then
                    createHitboxForPlayer(player)
                end
            end)
        end
    end

    local lastHitboxUpdate = 0
    hitboxConnections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
        if not hitboxConfig.enabled then return end
        local now = tick()
        if now - lastHitboxUpdate < 0.1 then return end
        lastHitboxUpdate = now
        updateAllHitboxes()
    end)

    hitboxConnections.playerRemoving = game.Players.PlayerRemoving:Connect(function(player)
        local playerName = player.Name

        if hitboxParts[playerName] and hitboxParts[playerName].Parent then
            local hrp = hitboxParts[playerName]
            pcall(function()
                local visual = hrp:FindFirstChild("HitboxVisual")
                if visual then visual:Destroy() end
                hrp.Size = originalSizes[playerName] or Vector3.new(2, 2, 1)
                hrp.Transparency = 1
            end)
        end

        originalSizes[playerName] = nil
        hitboxParts[playerName]   = nil

        if hitboxConnections[playerName] then
            hitboxConnections[playerName]:Disconnect()
            hitboxConnections[playerName] = nil
        end
    end)
end

local function stopHitbox()
    for name, conn in pairs(hitboxConnections) do
        if conn then
            pcall(function()
                if typeof(conn) == "RBXScriptConnection" then
                    conn:Disconnect()
                end
            end)
        end
    end
    hitboxConnections = {}

    for playerName, hrp in pairs(hitboxParts) do
        if hrp and hrp.Parent then
            pcall(function()
                local visual = hrp:FindFirstChild("HitboxVisual")
                if visual then visual:Destroy() end
                hrp.Size = originalSizes[playerName] or Vector3.new(2, 2, 1)
                hrp.Transparency = 1
                hrp.CanCollide = false
            end)
        end
    end

    hitboxParts = {}
    originalSizes = {}
end

-- ==================== ESP JOGADORES ====================

local function CreateESP(targetPlayer)
    if targetPlayer == game.Players.LocalPlayer then return end

    local function ApplyESP(character)
        if not character then return end

        local root = character:WaitForChild("HumanoidRootPart", 3)
        if not root then return end

        local highlight = character:FindFirstChild("MoonHighlight") or Instance.new("Highlight")
        highlight.Name            = "MoonHighlight"
        highlight.Parent          = character
        highlight.Adornee         = character
        highlight.FillTransparency    = 1
        highlight.OutlineTransparency = 0
        highlight.DepthMode       = Enum.HighlightDepthMode.AlwaysOnTop

        root.LocalTransparencyModifier = 1

        local bodyModel = nil

        local tag = root:FindFirstChild("MoonTag") or Instance.new("BillboardGui")
        tag.Name = "MoonTag"
        tag.Size = UDim2.new(0, 200, 0, 50)
        tag.AlwaysOnTop = true
        tag.StudsOffset = Vector3.new(0, 3.5, 0)
        tag.Parent = root

        local label = tag:FindFirstChild("Label") or Instance.new("TextLabel")
        label.Name = "Label"
        label.Parent = tag
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(1, 0, 1, 0)
        label.Text = targetPlayer.Name
        label.Font = Enum.Font.GothamBold
        label.TextSize = espConfig.nameSize
        label.TextStrokeTransparency = 0
        label.TextScaled = false

        local updateConnection
        local lastESPUpdate = 0
        updateConnection = game:GetService("RunService").Heartbeat:Connect(function()
            local now = tick()
            if now - lastESPUpdate < 0.1 then return end
            lastESPUpdate = now

            if not character or not character.Parent then
                if updateConnection then
                    updateConnection:Disconnect()
                    updateConnection = nil
                end
                for i = #espConnections, 1, -1 do
                    local c = espConnections[i]
                    if c.connection == updateConnection or
                       (c.player == targetPlayer and not c.charConnection) then
                        table.remove(espConnections, i)
                    end
                end
                return
            end

            if not espConfig.enabled then return end

            local color = espConfig.innocentColor

            local backpack = targetPlayer:FindFirstChild("Backpack")
            local hasKnife = (backpack and backpack:FindFirstChild("Knife")) or character:FindFirstChild("Knife")
            local hasGun = (backpack and backpack:FindFirstChild("Gun")) or character:FindFirstChild("Gun")

            if hasKnife then
                color = espConfig.murdererColor
            elseif hasGun then
                color = espConfig.sheriffColor
            end

            highlight.OutlineColor = color
            label.TextColor3 = color
            label.Text = targetPlayer.Name
            label.TextSize = espConfig.nameSize

            tag.Enabled = espConfig.nameEnabled and espConfig.enabled
        end)

        table.insert(espConnections, {
            player = targetPlayer,
            connection = updateConnection,
            highlight = highlight,
            tag = tag,
            bodyModel = bodyModel
        })
    end

    if targetPlayer.Character then
        ApplyESP(targetPlayer.Character)
    end

    local charConnection = targetPlayer.CharacterAdded:Connect(ApplyESP)
    table.insert(espConnections, {
        player = targetPlayer,
        connection = charConnection,
        charConnection = true
    })
end

local function enablePlayerESP()
    if espRunning then return end
    espRunning = true
    espConfig.enabled = true

    for _, conn in pairs(espConnections) do
        if conn.connection and conn.connection.Connected then
            conn.connection:Disconnect()
        end
        if conn.highlight then
            conn.highlight:Destroy()
        end
        if conn.tag then
            conn.tag:Destroy()
        end
    end
    espConnections = {}

    for _, plr in pairs(game.Players:GetPlayers()) do
        CreateESP(plr)
    end

    local playerAddedConnection = game.Players.PlayerAdded:Connect(CreateESP)
    table.insert(espConnections, {connection = playerAddedConnection})

    local playerRemovingConnection = game.Players.PlayerRemoving:Connect(function(plr)
        for i = #espConnections, 1, -1 do
            local conn = espConnections[i]
            if conn.player == plr then
                if conn.connection and conn.connection.Connected then
                    conn.connection:Disconnect()
                end
                if conn.highlight then
                    conn.highlight:Destroy()
                end
                if conn.tag then
                    conn.tag:Destroy()
                end
                table.remove(espConnections, i)
            end
        end
    end)
    table.insert(espConnections, {connection = playerRemovingConnection})
end

local function disablePlayerESP()
    espRunning = false
    espConfig.enabled = false

    for _, conn in pairs(espConnections) do
        if conn.connection and conn.connection.Connected then
            conn.connection:Disconnect()
        end
        if conn.highlight and conn.highlight.Parent then
            conn.highlight:Destroy()
        end
        if conn.tag and conn.tag.Parent then
            conn.tag:Destroy()
        end
        if conn.player and conn.player.Character then
            local hrp = conn.player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then hrp.LocalTransparencyModifier = 0 end
        end
    end
    espConnections = {}

    for _, plr in pairs(game.Players:GetPlayers()) do
        if plr.Character then
            local highlight = plr.Character:FindFirstChild("MoonHighlight")
            if highlight then highlight:Destroy() end

            local root = plr.Character:FindFirstChild("HumanoidRootPart")
            if root then
                local tag = root:FindFirstChild("MoonTag")
                if tag then tag:Destroy() end
                root.LocalTransparencyModifier = 0
            end
        end
    end
end

-- ==================== ESP ARMA ====================

local gunESPConnection = nil

local function applyGunESP(v)
    if v.Name ~= "GunDrop" then return end
    if not v:FindFirstChild("GunESP_Highlight") then
        local highlight = Instance.new("Highlight")
        highlight.Name = "GunESP_Highlight"
        highlight.Parent = v
        highlight.FillColor = Color3.fromRGB(255, 255, 0)
        highlight.OutlineColor = Color3.new(1, 1, 1)
        highlight.FillTransparency = 0.5
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    end
    if not v:FindFirstChild("GunESP_Name") then
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "GunESP_Name"
        billboard.Parent = v
        billboard.AlwaysOnTop = true
        billboard.Size = UDim2.new(0, 100, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 2, 0)
        local label = Instance.new("TextLabel")
        label.Parent = billboard
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(1, 0, 1, 0)
        label.Text = "GUN"
        label.TextColor3 = Color3.fromRGB(255, 255, 0)
        label.TextStrokeTransparency = 0
        label.TextSize = 14
        label.Font = Enum.Font.SourceSansBold
    end
end

local function enableGunESP()
    if gunESPConnection then return end
    for _, v in pairs(workspace:GetDescendants()) do
        applyGunESP(v)
    end
    gunESPConnection = functions.createconnection("GunESP_Loop", workspace.DescendantAdded, function(v)
        if espConfig.gunEnabled then
            applyGunESP(v)
        end
    end)
end

local function disableGunESP()
    espConfig.gunEnabled = false
    functions.closeconnection("GunESP_Loop")
    gunESPConnection = nil
    for _, v in pairs(workspace:GetDescendants()) do
        if v:FindFirstChild("GunESP_Highlight") then v.GunESP_Highlight:Destroy() end
        if v:FindFirstChild("GunESP_Name") then v.GunESP_Name:Destroy() end
    end
end

-- ==================== ESP MOEDA ====================

local coinESPConnection = nil

local function aplicarCoinESP(objeto)
    if objeto:FindFirstChild("Coin_XRAY") then return end
    local adorn = Instance.new("BoxHandleAdornment")
    adorn.Name = "Coin_XRAY"
    adorn.AlwaysOnTop = true
    adorn.Adornee = objeto
    adorn.ZIndex = 5
    adorn.Size = objeto.Size
    adorn.Color3 = Color3.fromRGB(255, 215, 0)
    adorn.Transparency = 0.6
    adorn.Parent = objeto
    objeto.AncestryChanged:Connect(function(_, parent)
        if not parent then adorn:Destroy() end
    end)
end

local function enableCoinESP()
    if coinESPConnection then return end
    for _, v in pairs(workspace:GetDescendants()) do
        if v.Name == "Coin_Server" and v:IsA("BasePart") then
            aplicarCoinESP(v)
        end
    end
    coinESPConnection = functions.createconnection("CoinESP_Added", workspace.DescendantAdded, function(new)
        if espConfig.coinEnabled and new.Name == "Coin_Server" and new:IsA("BasePart") then
            aplicarCoinESP(new)
        end
    end)
end

local function disableCoinESP()
    espConfig.coinEnabled = false
    functions.closeconnection("CoinESP_Added")
    coinESPConnection = nil
    for _, v in pairs(workspace:GetDescendants()) do
        if v:FindFirstChild("Coin_XRAY") then v.Coin_XRAY:Destroy() end
    end
end

-- ==================== NOCLIP ====================

local noclipParts = {}

local function cacheNoclipParts()
    noclipParts = {}
    local char = game.Players.LocalPlayer.Character
    if not char then return end
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            noclipParts[#noclipParts + 1] = part
        end
    end
end

local function startNoClip()
    noclipActive = true
    cacheNoclipParts()

    functions.createconnection("NoClip", "Stepped", function()
        if not noclipActive then return end
        for i = 1, #noclipParts do
            local part = noclipParts[i]
            if part and part.Parent then
                part.CanCollide = false
            end
        end
    end)
end

local function stopNoClip()
    noclipActive = false
    functions.closeconnection("NoClip")
    for i = 1, #noclipParts do
        local part = noclipParts[i]
        if part and part.Parent then
            part.CanCollide = true
        end
    end
    noclipParts = {}
end

-- ==================== SPEED E JUMP ====================

local function setSpeed(value)
    MY_SPEED = value

    local char = game.Players.LocalPlayer.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = value
        end
    end
end

local function setJump(value)
    MY_JUMP = value

    local char = game.Players.LocalPlayer.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.JumpPower = value
        end
    end
end

local speedWatchConn = nil
local jumpWatchConn  = nil

local function hookHumanoidStats(humanoid)
    if speedWatchConn then speedWatchConn:Disconnect() end
    if jumpWatchConn  then jumpWatchConn:Disconnect()  end

    speedWatchConn = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if MY_SPEED ~= 16 and humanoid.WalkSpeed ~= MY_SPEED then
            humanoid.WalkSpeed = MY_SPEED
        end
    end)
    jumpWatchConn = humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
        if MY_JUMP ~= 50 and humanoid.JumpPower ~= MY_JUMP then
            humanoid.JumpPower = MY_JUMP
        end
    end)
end

-- ==================== ANTI-AFK ====================

local antiAFKActive = false
local antiAFKConnection = nil

local function startAntiAFK()
    antiAFKActive = true
    local VU = game:GetService("VirtualUser")
    antiAFKConnection = game.Players.LocalPlayer.Idled:Connect(function()
        VU:CaptureController()
        VU:ClickButton2(Vector2.new())
    end)
end

local function stopAntiAFK()
    antiAFKActive = false
    if antiAFKConnection then
        antiAFKConnection:Disconnect()
        antiAFKConnection = nil
    end
end

-- ==================== TABS UI ====================

-- ==================== SHERIFF TAB ====================
do
    sheriffTab:AddSection("Shot Configuration")

    sheriffTab:AddKeybind("AutoShotKeybind", {
        Title = "Auto Shot Hotkey",
        Description = "Press to shoot once",
        Default = "E",
        Callback = function()
            local success, errorMsg = pcall(function()
                Atirar()
            end)

            if not success then
                warn("Hotkey Shot Error:", errorMsg)
            end
        end
    })

    sheriffTab:AddDropdown("ShotSpeed", {
        Title = "Shot Speed",
        Description = "Change fire rate delay",
        Values = {"Fast", "Medium", "Slow"},
        Default = "Medium",
        Callback = function(value)
            if value == "Fast" then
                delayTiro = 0.15
            elseif value == "Medium" then
                delayTiro = 0.3
            else
                delayTiro = 0.5
            end
        end
    })

    sheriffTab:AddToggle("UnequipAfterShot", {
        Title = "Unequip After Shot",
        Description = "Auto-unequip weapon after shooting",
        Default = false,
        Callback = function(value)
            sheriffConfig.UnequipAfterShot = value
        end
    })

    sheriffTab:AddSlider("HolsterDelay", {
        Title = "Holster Delay",
        Description = "Delay before unequipping (seconds)",
        Default = 0.0,
        Min = 0.0,
        Max = 2.0,
        Rounding = 2,
        Callback = function(value)
            delayHolster = value
        end
    })

    sheriffTab:AddSection("On-Screen Button")

    sheriffTab:AddToggle("ShowButton", {
        Title = "Show Auto Shot Button",
        Description = "Display button on screen to shoot",
        Default = false,
        Callback = function(value)
            sheriffConfig.showButton = value
            if value then
                CriarBotaoTela()
            else
                RemoverBotaoTela()
            end
        end
    })

    sheriffTab:AddToggle("DraggableButton", {
        Title = "Draggable Button",
        Description = "Enable to move the button around",
        Default = false,
        Callback = function(value)
            botaoArrastavel = value
        end
    })

    sheriffTab:AddSlider("ButtonSize", {
        Title = "Button Size",
        Description = "Adjust the button size",
        Default = 80,
        Min = 50,
        Max = 150,
        Rounding = 0,
        Callback = function(value)
            tamanhoBot = value
            AtualizarTamanhoBotao()
        end
    })

    sheriffTab:AddSection("Advanced Targeting")

    sheriffTab:AddToggle("WallCheck", {
        Title = "Wall Check",
        Description = "Only shoot if target is visible (no walls blocking)",
        Default = false,
        Callback = function(value)
            autoShotConfig.wallCheck = value
        end
    })

    sheriffTab:AddSection("Prediction Settings")

    sheriffTab:AddToggle("PingPrediction", {
        Title = "Ping Prediction",
        Description = "Compensate for network latency",
        Default = true,
        Callback = function(value)
            sheriffConfig.PingPrediction = value
        end
    })

    sheriffTab:AddSlider("PingSensitivity", {
        Title = "Ping Sensitivity",
        Description = "Adjust ping compensation",
        Default = 1.18,
        Min = 0.5,
        Max = 2.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.PingSensitivity = value
        end
    })

    sheriffTab:AddToggle("JumpPrediction", {
        Title = "Jump Prediction",
        Description = "Compensate when target is airborne",
        Default = true,
        Callback = function(value)
            sheriffConfig.JumpPrediction = value
        end
    })

    sheriffTab:AddSlider("HorizontalMultiplier", {
        Title = "Horizontal Multiplier",
        Description = "Adjust horizontal prediction strength",
        Default = 1.00,
        Min = 0.1,
        Max = 2.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.HorizontalMultiplier = value
        end
    })

    sheriffTab:AddSlider("VerticalMultiplier", {
        Title = "Vertical Multiplier",
        Description = "Adjust vertical prediction strength",
        Default = 1.00,
        Min = 0.1,
        Max = 2.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.VerticalMultiplier = value
        end
    })

    sheriffTab:AddSlider("LeadTime", {
        Title = "Lead Time",
        Description = "Offset fixo alem do ping (0 = so ping)",
        Default = 0.01,
        Min = 0.00,
        Max = 0.15,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.LeadTime = value
        end
    })

    sheriffTab:AddSlider("BulletSpeed", {
        Title = "Bullet Speed",
        Description = "Velocidade do projetil (studs/s). Errou atras = aumentar, errou na frente = diminuir",
        Default = 500,
        Min = 300,
        Max = 800,
        Rounding = 0,
        Callback = function(value)
            BULLET_SPEED = value
        end
    })

    sheriffTab:AddSlider("VerticalDistanceScale", {
        Title = "Vertical Distance Scale",
        Description = "Vertical adjustment for long range",
        Default = 2.00,
        Min = 1,
        Max = 20,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.VerticalDistanceScale = value
        end
    })

    sheriffTab:AddSlider("MaxDistance", {
        Title = "Max Prediction Distance",
        Description = "Maximum distance for prediction",
        Default = 350,
        Min = 100,
        Max = 500,
        Rounding = 0,
        Callback = function(value)
            sheriffConfig.MaxPredictionDistance = value
        end
    })

    sheriffTab:AddSlider("XMultiplier", {
        Title = "X Multiplier",
        Description = "Fine-tune X axis offset",
        Default = 0.00,
        Min = -1.0,
        Max = 1.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.XMultiplier = value
        end
    })

    sheriffTab:AddSlider("ZMultiplier", {
        Title = "Z Multiplier",
        Description = "Fine-tune Z axis offset",
        Default = 0.00,
        Min = -1.0,
        Max = 1.0,
        Rounding = 2,
        Callback = function(value)
            sheriffConfig.ZMultiplier = value
        end
    })
end

-- ==================== MURDER TAB ====================
do
    murderTab:AddSection("Murder Tools")

    murderTab:AddSection("Hitbox Expander")

    murderTab:AddToggle("ExpandHitbox", {
        Title = "Expand Hitboxes",
        Description = "Enlarge player hitboxes for easier hits",
        Default = false,
        Callback = function(value)
            hitboxConfig.enabled = value
            if value then
                startHitbox()
            else
                stopHitbox()
            end
        end
    })

    murderTab:AddSlider("HitboxSize", {
        Title = "Hitbox Size",
        Description = "Size of the expanded hitbox",
        Default = 10,
        Min = 5,
        Max = 50,
        Rounding = 0,
        Callback = function(value)
            hitboxConfig.size = value
        end
    })

    murderTab:AddToggle("ShowHitbox", {
        Title = "Show Hitbox ESP",
        Description = "Display visual box around expanded hitbox",
        Default = true,
        Callback = function(value)
            hitboxConfig.visible = value
        end
    })

    murderTab:AddSlider("HitboxTransparency", {
        Title = "Hitbox Transparency",
        Description = "0 = solid, 1 = invisible",
        Default = 0.5,
        Min = 0.0,
        Max = 1.0,
        Rounding = 2,
        Callback = function(value)
            hitboxConfig.transparency = value
        end
    })

    murderTab:AddColorpicker("HitboxColor", {
        Title = "Hitbox Color",
        Description = "Color of the hitbox visualization",
        Default = Color3.fromRGB(255, 0, 80),
        Callback = function(value)
            hitboxConfig.color = value
        end
    })

    murderTab:AddParagraph({
        Title = "How it works",
        Content = "Creates an invisible expanded hitbox around players that detects hits. Visual box shows the hitbox area."
    })
end

-- ==================== PLAYER TAB ====================
do
    playerTab:AddSection("Movement")

    playerTab:AddSlider("Speed", {
        Title = "Walk Speed",
        Description = "Change your walk speed",
        Default = 16,
        Min = 16,
        Max = 200,
        Rounding = 0,
        Callback = function(value)
            setSpeed(value)
        end
    })

    playerTab:AddSlider("Jump", {
        Title = "Jump Power",
        Description = "Change your jump power",
        Default = 50,
        Min = 50,
        Max = 200,
        Rounding = 0,
        Callback = function(value)
            setJump(value)
        end
    })

    playerTab:AddSection("Abilities")

    playerTab:AddToggle("NoClip", {
        Title = "No Clip",
        Description = "Walk through walls",
        Default = false,
        Callback = function(value)
            if value then
                startNoClip()
            else
                stopNoClip()
            end
        end
    })
end

-- ==================== VISUAL TAB ====================
do
    visualTab:AddSection("ESP Settings")

    local ToggleESP = visualTab:AddToggle("PlayerESP", {
        Title = "Player ESP",
        Description = "See players through walls with highlights",
        Default = false
    })

    ToggleESP:OnChanged(function(value)
        if value then
            enablePlayerESP()
        else
            disablePlayerESP()
        end
    end)

    visualTab:AddSection("ESP Name Settings")

    local ToggleName = visualTab:AddToggle("ESPName", {
        Title = "Show Name",
        Description = "Display player names above them",
        Default = true
    })

    ToggleName:OnChanged(function(value)
        espConfig.nameEnabled = value
    end)

    visualTab:AddSlider("NameSize", {
        Title = "Name Size",
        Description = "Adjust the text size of names",
        Default = 14,
        Min = 10,
        Max = 30,
        Rounding = 0,
        Callback = function(value)
            espConfig.nameSize = value
        end
    })

    visualTab:AddSection("ESP Colors")

    visualTab:AddColorpicker("InnocentColor", {
        Title = "Innocent Color",
        Description = "Color for innocent players",
        Default = Color3.fromHex("#00ff00"),
        Callback = function(value)
            espConfig.innocentColor = value
        end
    })

    visualTab:AddColorpicker("SheriffColor", {
        Title = "Sheriff Color",
        Description = "Color for sheriff player",
        Default = Color3.fromHex("#0026ff"),
        Callback = function(value)
            espConfig.sheriffColor = value
        end
    })

    visualTab:AddColorpicker("MurdererColor", {
        Title = "Murderer Color",
        Description = "Color for murderer player",
        Default = Color3.fromHex("#ff0000"),
        Callback = function(value)
            espConfig.murdererColor = value
        end
    })

    visualTab:AddParagraph({
        Title = "ESP Info",
        Content = "ESP highlights players with colored outlines. Green = Innocent, Blue = Sheriff, Red = Murderer. Customize colors and name display to your preference."
    })

    visualTab:AddSection("Item ESP")

    visualTab:AddParagraph({
        Title = "Item ESP",
        Content = "Show dropped guns and coins on the map through walls."
    })

    local ToggleGunESP = visualTab:AddToggle("GunESP", {
        Title = "Gun ESP",
        Description = "Highlight dropped guns on the map",
        Default = false
    })

    ToggleGunESP:OnChanged(function(value)
        espConfig.gunEnabled = value
        if value then
            enableGunESP()
        else
            disableGunESP()
        end
    end)

    local ToggleCoinESP = visualTab:AddToggle("CoinESP", {
        Title = "Coin ESP",
        Description = "Highlight coins on the map",
        Default = false
    })

    ToggleCoinESP:OnChanged(function(value)
        espConfig.coinEnabled = value
        if value then
            enableCoinESP()
        else
            disableCoinESP()
        end
    end)
end

-- ==================== AUTO FARM TAB ====================
do
    autoFarmTab:AddSection("Auto Farm")

    autoFarmTab:AddToggle("AntiAFK", {
        Title = "Anti-AFK",
        Description = "Prevent being kicked for inactivity",
        Default = false,
        Callback = function(value)
            if value then
                startAntiAFK()
            else
                stopAntiAFK()
            end
        end
    })

    autoFarmTab:AddParagraph({
        Title = "Info",
        Content = "Anti-AFK keeps you in the game by simulating activity."
    })
end

-- ==================== INICIALIZAÇÃO ====================

game.Players.PlayerRemoving:Connect(function(player)
    local char = player.Character
    if char then
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            velocityHistory[hrp] = nil
            accelerationHistory[hrp] = nil
        end
    end
end)

game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
    task.wait(0.5)

    podeAtirar = true
    equipAttempts = 0

    velocityHistory = {}
    accelerationHistory = {}

    local humanoid = character:WaitForChild("Humanoid", 5)
    if humanoid then
        if MY_SPEED ~= 16 then
            humanoid.WalkSpeed = MY_SPEED
        end
        if MY_JUMP ~= 50 then
            humanoid.JumpPower = MY_JUMP
        end
        hookHumanoidStats(humanoid)
    end

    if sheriffConfig.showButton and not botaoTela then
        task.wait(0.5)
        CriarBotaoTela()
    end

    if noclipActive then
        cacheNoclipParts()
    end

end)

podeAtirar = true

local _initChar = game.Players.LocalPlayer.Character
if _initChar then
    local _initHum = _initChar:FindFirstChild("Humanoid")
    if _initHum then hookHumanoidStats(_initHum) end
end

GUI.SaveManager:SetFolder("moon")
GUI.SaveManager:SetFolder("moon/mm2")
GUI.InterfaceManager:SetLibrary(GUI)
GUI.InterfaceManager:BuildInterfaceSection(settingsTab)
GUI.SaveManager:IgnoreThemeSettings()
GUI.SaveManager:SetLibrary(GUI)
GUI.SaveManager:BuildConfigSection(settingsTab)
GUI.SaveManager:LoadAutoloadConfig()
